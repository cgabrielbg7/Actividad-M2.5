# -*- coding: utf-8 -*-
"""Actividad M2.5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DKFKwQdkBIwS0-3er5OdcDAyOl1XeoPo
"""

#Importar las bibliotecas
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten, Dense, Softmax
from tensorflow.keras.datasets import cifar10
from tensorflow.keras.utils import to_categorical
from tensorflow.keras.optimizers import Adam

# Definir el modelo CNN
model = Sequential([
    Conv2D(32, (3, 3), activation='relu', input_shape=(32, 32, 3)),
    MaxPooling2D((2, 2)),
    Flatten(),
    Dense(128, activation='relu'),
    Dense(10),
    Softmax()
])

# Compilar el modelo
model.compile(
    optimizer='adam',
    loss='categorical_crossentropy',
    metrics=['accuracy']
)

# Cargar y preparar los datos CIFAR-10
(train_images, train_labels), (test_images, test_labels) = cifar10.load_data()

# Normalizar los pixeles de imágenes entre 0 y 1
train_images, test_images = train_images / 255.0, test_images / 255.0

# Codificar etiquetas categóricamente
train_labels = to_categorical(train_labels)
test_labels = to_categorical(test_labels)

# Entrenar el modelo
history = model.fit(
    train_images,
    train_labels,
    epochs=10,
    validation_data=(test_images, test_labels)
)

# Imprimir la precisión del modelo
print("Precisión del modelo en datos de prueba:", model.evaluate(test_images, test_labels)[1])

# Modelo modificado con más capas, más filtros y dropout
model_modificado = Sequential([
    Conv2D(32, (3, 3), activation='relu', input_shape=(32, 32, 3)), # Primera capa convolucional
    MaxPooling2D((2, 2)),
    Conv2D(64, (3, 3), activation='relu'),  # Segunda capa convolucional
    MaxPooling2D((2, 2)),
    Conv2D(128, (3, 3), activation='relu'), # Tercera capa convolucional
    MaxPooling2D((2, 2)),
    Flatten(),
    Dense(128, activation='relu'),
    tf.keras.layers.Dropout(0.5),
    Dense(10),
    Softmax()
])

# Compilar el modelo modificado
model_modificado.compile(
    optimizer='adam',
    loss='categorical_crossentropy',
    metrics=['accuracy']
)

# Entrenar el modelo modificado
history_modificado = model_modificado.fit(
    train_images,
    train_labels,
    epochs=10,
    validation_data=(test_images, test_labels)
)

# Imprimir la precisión del modelo modificado en datos de prueba
print("Precisión del modelo modificado en datos de prueba:", model_modificado.evaluate(test_images, test_labels)[1])

# Hiperparámetros a explorar
learning_rates = [0.001, 0.01, 0.1]
batch_sizes = [32, 64, 128]
epochs = [10, 20, 30]

# Guardar los resultados para cada configuración
results = []

for lr in learning_rates:
    for batch_size in batch_sizes:
        for epoch in epochs:
            print(f"Training model with LR={lr}, Batch Size={batch_size}, Epochs={epoch}")
            model = Sequential([
                Conv2D(32, (3, 3), activation='relu', input_shape=(32, 32, 3)),
                MaxPooling2D((2, 2)),
                Flatten(),
                Dense(128, activation='relu'),
                Dense(10),
                Softmax()
            ])

            # Compilar el modelo con la tasa de aprendizaje actual
            model.compile(
                optimizer=Adam(learning_rate=lr),
                loss='categorical_crossentropy',
                metrics=['accuracy']
            )

            # Entrenar el modelo
            history = model.fit(
                train_images,
                train_labels,
                epochs=epoch,
                batch_size=batch_size,
                validation_data=(test_images, test_labels),
                verbose=0
            )

            # Evaluar el modelo y guardar los resultados
            test_accuracy = model.evaluate(test_images, test_labels, verbose=0)[1]
            print(f"Test Accuracy: {test_accuracy}")
            results.append((lr, batch_size, epoch, test_accuracy))

# Imprimir los resultados
for res in results:
    print(f"LR: {res[0]}, Batch Size: {res[1]}, Epochs: {res[2]}, Accuracy: {res[3]}")